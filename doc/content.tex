%% LaTeX2e file `content.tex'
%% generated by the `filecontents' environment
%% from source `CLaTeX' on 2012/11/11.
%%
\lstset{language=Turing}
%\lstset{basicstyle=\ttfamily}

% +----------------------------------------------------------------------------+
% | Introduction
% +----------------------------------------------------------------------------+
\section{Einf\"uhrung}

\texttt{Turing} entstand im Jahre 1982 an der Universit\"at Toronto aus dem Versuch heraus, die dazumal verwendete, aber nicht mehr zeitgem\"a\ss{}e, Programmiersprache \texttt{PL/1} im universit\"aren Unterricht zu ersetzen. \\
\texttt{Pascal} oder die ebenfalls an der Universit\"at entwickelte Programmiersprache \texttt{Euclid} sollten \texttt{PL/1} urspr\"unglich ersetzen. \texttt{Euclid} stellte sich aber als zu komplex f\"ur den Programmierneuling dar und \texttt{Pascal}, obwohl leicht zu erlernen, wies einige Schw\"achen auf, die die Universit\"at dazu veranlassten eine neue Programmiersprache zu entwerfen \cite{Holt:88}.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Zielsetzungen der neuen Sprache}

Beim Design der Sprache orientierten sich die beiden Entwickler Ric Holt und James Cordy stark an Pascal und Euclid, versuchten aber eine einfachere Syntax zu erzielen, die es Einsteigern erm\"oglichen sollte, \texttt{Turing} schnell und effizient zu erlernen. \cite{Hume:01}. \\
Die neue Sprache sollte aber auch f\"ur professionelle Entwickler nutzbar sein. Um den Anforderungen aktueller Programmiersprachen gerecht werden zu k\"onnen, unterst\"utzte \texttt{Turing} unter anderem dynamische Strings und Arrays und die Organisation gro\ss{}er Projekte in Modulen. Mit den Erweiterungen zu System Turing und objekt-orientiertem Turing kamen die Aspekte der systemnahen, parallelen und der objekt-orientierten Programmierung hinzu \cite{Holt:99}.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Anwendungsbereiche und Verbreitung}

Besonders h\"aufig fand \texttt{Turing} aber Anwendung in universit\"aren Kursen nicht nur als Einf\"uhrungssprache in die grundlegenden Konzepte, sondern auch in Kursen aus den Gebieten der Betriebssysteme, Compilerentwicklung und Systemprogrammierung. \\
Au\ss{}erhalb der Universit\"at fand \texttt{Turing} breiten Anklang an den Highschools des Bundesstaates Ontario, Kanada, an der sie auch heute noch zuweilen im Informatikunterricht angewendet wird \cite{Holt:88}. 

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Aufbau der Arbeit}

Im n\"achsten Kapitel werden die wichtigsten Erweiterungen und Entwicklungen in der Geschichte von \texttt{Turing} kurz Erw\"ahnung finden. \\
Kapitel \ref{chap:basics} widmet sich der heute g\"ultigen elementaren Syntax. Neben Datentypen, Kontrollstrukturen und Subroutinen, geht diese Kapitel besonders auf Strings und Arrays ein. \\
Prozesse und Zeiger finden in Kapitel \ref{chap:system} Erw\"ahnung und Kapitel \ref{chap:oop} widmet sich vollends den objekt-orientierten Mechanismen, die \texttt{Turing} zur Verf\"ugung stellt. \\
Das letzte Kapitel schlie\ss{}t die Diskussion mit einigen zusammenfasssenden Bemerkungen.


% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\section{Turing-Implementierungen und -Derivate}
\label{chap:imp}

Seit seiner erstmaligen Entwicklung in den fr\"uhen 1980er Jahren unterwarf sich \texttt{Turing} einiger Neuerungen und Erweiterungen, die die Sprache weiterhin attraktiv f\"ur Anf\"anger wie Professionelle gestalten sollten. Besonders wichtig waren dabei die Erweiterung hin zu einer Systemprogrammiersprache um hardwarenahe L\"osungen zu entwickeln, und der Schritt in Richtung einer objekt-orientierten Sprache um Entwicklungen gro\ss{}er Anwendungen \"ubersichtlicher zu halten. \\

Neben diesen Erweiterungen kam es auch zur Implementierung offener Compiler, w\"ahrend und besonders nachdem der Quellcode des urspr\"ungliche \texttt{Turing} 2007 ver\"offentlicht und die Weiterentwicklung von Seiten der Firma Holtsoft eingestellt wurden \cite{www:tur}.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Holtsoft Turing}

{\em Holtsoft Turing} war die propriet\"are Implementierung der \texttt{Turing}-Programmier-sprache. Die Fortf\"uhrung, der an der Universit\"at Toronto begonnenen Arbeit, geschah in dem von Dr. Ric Holt gegr\"undeten Unternehmen {\em Holtsoft}, das auch die kommerzielle Verbreitung des Compilers vorantrieb. \\
Einer der Kunden war der Bundesstaat Ontario, der \texttt{Turing} an allen Schulen im Informatikunterricht einsetzte.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Turing Plus oder System Turing}

Mit {\em System Turing} ({\em Turing Plus}) betrat \texttt{Turing} die B\"uhne der systemnahen Programmiersprachen und betrachtete sich als Alternative zu bereits etablierten Sprachen wie C oder Ada. \\
Zu den neuen Features z\"ahlten unter anderem Zeiger und entsprechende Zeigerarithmetik, vorzeichenlose Zahlen unterschiedlicher Gr\"o\ss{}en, explizite Typkonvertierungen, Prozesserzeugung und -synchronisation sowie Interruptbehandlungsmechanismen \cite{Holt:88}. Kapitel \ref{chap:system} stellt einige der Konzepte n\"aher vor.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Numerical Turing}

{\em Numerical Turing} war eine experimentelle Erweiterung der \texttt{Turing}-Programmier-sprache um numerisch-wissenschaftliche Berechnungen bequemer implementieren zu k\"onnen \cite{Hull:85}. Die Erweiterungen wurden allerdings nie Teil der \texttt{Turing}- Spezifikation und werden von heutigen Compilern nicht unterst\"utzt.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Objekt-orientiertes Turing}

Im Jahr 1992 gelang \texttt{Turing} der Schritt hin zu einer objekt-orientierten Sprache. System Turing erhielt die F\"ahigkeit Klassen zu definieren, Objekte zu erzeugen und Mittel der Vererbung \cite{Hume:01}.

In Kapitel \ref{chap:oop} werden die M\"oglichkeiten der objekt-orientierten Programmierung detailliert vorgestellt.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{OpenT}

{\em OpenT} ist eine offene Implementierung mit ann\"ahernd vollst\"andiger Kompatibilit\"at zu objekt-orientiertem Turing. Die letzte Aktivit\"at im OpenT-Repository datiert zur\"uck auf den 1. August 2009 \cite{www:opent}.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Open Turing}

{\em Open Turing} beruht auf dem von Holtsoft freigegebenen Sourcecode der letzten unver\"offentlichten Version des Holtsoft-Turing- Compilers. Der offene Compiler bietet vollst\"andige Kompatibilit\"at zur \texttt{Turing} Spezifikation und kann mit neuen Erweiterungen, wie Unterst\"utzung f\"ur 3D-Grafik und einer nativen HashMap-Implementierung aufwarten. \texttt{Turing}-Code soll im Vergleich zur originalen Implementierung auch bis zu 50 Prozent schneller ausgef\"uhrt werden \cite{www:ot}. \\
Das Projekt steht unter der MIT Lizenz und kann von \texttt{github}\footnote{https://github.com/Open-Turing-Project/OpenTuring} bezogen werden. 

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Vergleich mit Pascal}

\texttt{Turing} sollte als eine Weiterentwicklung von \texttt{Pascal} verstanden werden \cite{Perelgut:88}. Hier sollen einige syntaktische Verbesserungen durch \texttt{Turing} aufgezeigt werden. Listing \ref{LIS:comparison:pascal} zeigt ein einfaches Programm in \texttt{Pascal}.

\lstset{caption={Ein einfaches Programm in \texttt{Pascal} \cite{Perelgut:88}.}}
\lstset{label=LIS:comparison:pascal}
\begin{table}[h!]
\begin{lstlisting}
program test (output);  {redundant header, semi-colon}
  var n,m integer;    {grouped dcl'ns at top of program}
begin                 {redundant begin}
  if n > 0 then       {no semi-colon, no un-init. check}
    if m < 0 then
      writeln('n>0, m<0');  {semi-colon changes meaning}
    else                 {applies to outer-if, NOT inner}
      writeln('n&m>0');  {wrong!!!, semi-colon redundant}
end.                     {period, NOT semi-colon}
\end{lstlisting}
\end{table}

Listing \ref{LIS:comparison:turing} implementiert das selbe Programm in \texttt{Turing}. Die Syntax in \texttt{Turing} verzichtet vollst\"andig auf Semikolons. Auch wurden einige Strukturen, wie der \lstinline{program}-Kopf und der \lstinline{begin ... end}-Block entfernt. Vereinfacht wurden damit auch Nuancen in der Syntax, wie der Punkt am Ende eines \texttt{Pascal} Programmes oder die Regeln zur korrekten Verwendung der Semikolons.

\lstset{caption={Ein einfaches Programm in \texttt{Turing} \cite{Perelgut:88}.}}
\lstset{label=LIS:comparison:turing}
\begin{table}[h!]
\begin{lstlisting}
                      % no header
var n, m : int        % declarations may appear anywhere
if n > 0 then         
  if m > 0 then
    put "n>0, m<0"    % simpler I/O
  else
    put "n&m>0" 
  end if              % clearly delimits statement
end if
                      % no redundant end, no period
\end{lstlisting}
\end{table}

Variablen k\"onnen in \texttt{Turing} an jeder beliebigen Stelle im Quellcode deklariert werden. In \texttt{Pascal} stehenn alle Variablendeklarationen im Programmkopf. \\
Die \lstinline{if}-Struktur wird mit einem \lstinline{end if} abgeschlossen und verhindert so Fehler bei verschachtelten \lstinline{if}-Bl\"ocken, wie sie in Listing \ref{LIS:comparison:pascal} auftreten. Der \lstinline{else}-Block geh\"ort in diesem Fall zum \"au\ss{}eren \lstinline{if} und nicht, wie in der Formatierung angedeutet, zum inneren Block.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\section{Elementare Sprachkonzepte}
\label{chap:basics}

Dieses Kapitel widmet sich der grundlegenden Syntax der \texttt{Turing}-Programmier-sprache. Alle erw\"ahnten Strukturen sind Teil der   heute g\"ultigen \texttt{Turing}-Spezifi-kation, in die die Erweiterungen von System Turing und objekt-orientiertem Turing einflossen. Die vorgestellten Inhalte sind \cite{Hume:01} entnommen oder fu\ss{}en auf eigenen Erfahrungen mit dem Compiler.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Hallo Welt}
Wie eingangs bereits erw\"ahnt, wurde \texttt{Turing} auch entwickelt, um einen leichten Einstieg in die Programmierung zu bieten. Dabei sollten einfache Programme auch einfach umzusetzen sein. Listing \ref{LIS:hello world} zeigt ein erweitertes ``Hello, World!''-Programm in \texttt{Turing}.

\lstset{caption={``Hello, World!'' Programm in \texttt{Turing}.}}
\lstset{label=LIS:hello world}
\begin{table}[h!]
\begin{lstlisting}
/*
  Hello, World! in Turing.
*/
put "Enter your first name: " ..
var firstName: string
get firstName : *                 % Read name.
put "Hello, ", firstName, "!"
\end{lstlisting}
\end{table}

Das obige Programm ist bereits vollst\"andig. \texttt{Turing} ben\"otigt wie Skriptsprachen keine \texttt{main}-Methode. \\

Mit \lstinline{put} k\"onnen Daten auf der Konsole ausgegeben werden. Dabei r\"uckt der Cursor nach jeder \lstinline{put}-Anweisung eine Zeile nach unten. Um das zu unterbinden, m\"ussen am Ende der Anweisung zwei Punkte angef\"ugt werden. \\
Es k\"onnen auch mehrere Daten in einer \lstinline{put}-Anweisung ausgegeben werden, indem diese durch Komma getrennt aneinander gereiht werden. \lstinline{put} wird diese hintereinander ausgeben. Sollte eine der Variablen eine Nummer sein, wird diese automatisch f\"ur die Ausgabe konvertiert.

Die Operation \lstinline{get} liest und konvertiert Eingaben entsprechend des Datentyps der Variable, in die gespeichert wird. \\
Werden mit \lstinline{get} Strings gelesen, so kann mit einem nachfolgenden Doppelpunkt die Anzahl der zu lesenden Zeichen angegeben werden. M\"ochten wir die gesamte Zeile lesen, so wird anstelle der Anzahl ein * angegeben. \\

Einzeilige Kommentare werden mit \texttt{\%} eingeleitet, mehrzeilige mit \texttt{/* ... */} umschlossen.  

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Primitive Datentypen}

\texttt{Turing} unterst\"utzt die f\"unf in Tabelle \ref{tab:datatypes} aufgelisteten primitive Datentypen.

\begin{table}[h!]
\begin{center}
  \begin{tabular}{|l|l|}
  \hline
  \texttt{char}    & Repr\"asentiert einen ASCII-Character \\
  \hline
  \texttt{string}  & Zeichenketten bis zu einer L\"ange von 255 Zeichen \\
  \hline
  \texttt{int}     & Vorzeichenbehaftete 32 Bit Ganzzahl  \\
  \hline
  \texttt{real}    & 32 Bit Flie\ss{}kommazahl \\
  \hline
  \texttt{boolean} & Entweder \texttt{true} oder \texttt{false} \\
  \hline
  \end{tabular}
\label{tab:datatypes}
\caption{Die f\"unf primitiven Datentypen in \texttt{Turing}.}
\end{center}
\end{table}

Die strikte Typisierung erlaubt keine impliziten Konvertierungen. Mit der Erweiterung durch Turing Plus kamen vorzeichenlose Ganzzahlen und die M\"oglich-keit explizit zu konvertieren hinzu.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Programmflussstrukturen}

In diesem Kapitel widmen wir uns den in \texttt{Turing} vorhandenen Programmflussstrukturen. Unterst\"utzt werden die \"ublichen Schleifen und Verzweigungen.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Schleifen}

\texttt{Turing} unterst\"utzt die \"ublichen Schleifenkonstrukte. Zum einen die unendliche Schleife (Listing \ref{LIS:loop}):

\lstset{caption={Die unendliche Schleife \cite{Hume:01}.}}
\lstset{label=LIS:loop}
\begin{table}[h!]
\begin{lstlisting}
const pi : real := 3.14159
loop
  var radius: real
  put "Enter radius " ..
  get radius
  exit when radius < 0
  put "Area is ", pi * radius ** 2
end loop
\end{lstlisting}
\end{table}

In einem Schleifenblock k\"onnen an jeder beliebigen Stelle \lstinline{exit when}-Beding-ungen zum Schleifenabbruch eingebracht werden. Ein Block kann auch beliebig viele dieser Abbruchbedingungen enthalten. \\  
Des Weiteren werden auch \lstinline{for}-Schleifen zur Verf\"ugung gestellt (Listing \ref{LIS:for}).

\lstset{caption={Die z\"ahlende Schleife \cite{Hume:01}.}}
\lstset{label=LIS:for}
\begin{table}[h!]
\begin{lstlisting}
var mark : int
var count : int
var sum : int := 0

put "How many marks: " ..
get count

for i : 1 .. count
  put "Mark ", i, ": " ..
  get mark
  sum := sum + mark
end for
put "Average is ", round(sum / count)
\end{lstlisting}
\end{table}

Die klassische \texttt{for}-Schleife kann dar\"uber hinaus in absteigender Folge durch iterieren. Die hierf\"ur n\"otige \"Anderung am Schleifenkopf s\"ahe wie folgt aus: 

\begin{table}[h!]
\begin{lstlisting}
for decreasing i : count .. 1
\end{lstlisting}
\end{table}

Zudem kann das Z\"ahlverhalten der Schleifenvariable ge\"andert werden. M\"ochten wir zum Beispiel \texttt{i} bei jedem Durchlauf um 2 erh\"ohen so k\"ame das folgenderma\ss{}en zum Ausdruck: 

\begin{table}[h!]
\begin{lstlisting}
for i : 1 .. count by 2
\end{lstlisting}
\end{table}

Wie in der infiniten Schleife, k\"onnen auch in der \texttt{for}-Schleife beliebig viele \lstinline{exit when} Ausdr\"ucke platziert werden.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{if-Verzweigungen}

Das Beispiel in Listing \ref{LIS:if} zeigt eine if-Verzweigung. Es k\"onnen beliebig viele \lstinline{elsif}-Bl\"ocke zwischen dem \lstinline{if} und \lstinline{else} Bl\"ocken stehen.

\lstset{caption={Die if-Struktur.}}
\lstset{label=LIS:if}
\begin{table}[h!]
\begin{lstlisting}
var x : int
get x
if x = 0 then
  put "Zero"
elsif x > 0 then
  put "Positive"
else
  put "Negative"
end if
\end{lstlisting}
\end{table}

Bedingungen k\"onnen alle Ausdr\"ucke sein, die zu \lstinline{boolean} ausgewertet werden k\"onnen. Dies sind insbesondere Vergleichsoperatoren wie \lstinline{=}, \lstinline{>=} oder \lstinline{not=}. Hinzu kommen die \"ublichen logischen Verkn\"upfungen \lstinline{and}, \lstinline{or} und ein eigener Operator f\"ur die Implikation \lstinline{=>}.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{case-Verzweigungen}

Die \lstinline{case}-Struktur erlaubt eine kompaktere Darstellung einer Mehrwegverzweigung. In \texttt{Turing} k\"onnen mit \lstinline{type} definierte Enumeratoren, Zahlen, einzelne Zeichen und dar\"uber hinaus auch Strings als Entscheidungsquellen herangezogen werden. 

\lstset{caption={Die case-Verzweigung.}}
\lstset{label=LIS:case}
\begin{table}[h!]
\begin{lstlisting}
var x : string
loop
   get x : *
   case x of
      label "stop": exit
      label       : put "Type 'stop' to exit."
   end case
end loop
\end{lstlisting}
\end{table} 

Nicht behandelte F\"alle k\"onnen mit einer leeren \lstinline{label:} Klausel behandelt werden.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Unterprogramme}

\texttt{Turing} unterscheidet strikt zwischen Funktionen und Prozeduren und stellt zum Teil Schl\"usselw\"orter zur Verf\"ugung,  die nur im jeweiligen Kontext einer Funktion oder Prozedur syntaktisch korrekt sind. \\
Listing \ref{LIS:proc} zeigt ein Beispiel zur Deklaration einer Prozedur. Die R\"uckkehr aus einer Prozedur ist an jeder Stelle im Prozedurrumpf mit \lstinline{return} m\"oglich.

\lstset{caption={Ein Beispiel f\"ur eine Prozedur \cite{Hume:01}.}}
\lstset{label=LIS:proc}
\begin{table}[h!]
\begin{lstlisting}
procedure triangles(size : int)
   if size < 1 then
      put "Size must be at leat 1."
      return
   end if
   % Outputs a triangle of size asterisks
   for i : 1 .. size
      put repeat ("*", i )
   end for
end triangles
\end{lstlisting}
\end{table}

\newpage

Listing \ref{LIS:fcn} zeigt eine Funktion. Im Gegensatz zu Prozeduren wird zus\"atzlich im Kopf der Funktion der Typ der R\"uckgabe angegeben. Ein Ergebnis dieses Typs kann an jeder Stelle mit \lstinline{result} an die Aufruferroutine zur\"uckgegeben werden.

\lstset{caption={Ein Beispiel einer Funktion \cite{Hume:01}.}}
\lstset{label=LIS:fcn}
\begin{table}[h!]
\begin{lstlisting}
function roundCent(amount : real) : real
   % Round amount to nearest cent
   result round (amount * 100) / 100
end roundCent
\end{lstlisting}
\end{table}

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Parameterlose Subroutinen}

Spezielle Syntax erlaubt \texttt{Turing} bei parameterlosen Subroutinen.

\lstset{caption={Parameterlose Subroutinen.}}
\lstset{label=LIS:proc0}
\begin{table}[h!]
\begin{lstlisting}
procedure print
   put "Print"
end print

print()
print
\end{lstlisting}
\end{table}

Diese verlangen weder bei der Deklaration der Routine noch beim Aufruf eben dieser keine Klammern. Die Aufrufe \lstinline{print} und \lstinline{print()} sind gleichwertig.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Aufruf vor Deklaration}

Um Subroutinen verwenden und aufrufen zu k\"onnen, m\"ussen deren entsprech-ende Deklarationen in der Sourcedatei vorher aufscheinen.
\texttt{Turing} stellt zwei Schl\"usselw\"orter zur Verf\"ugung die es erm\"oglichen Funktionen vor deren eigent-lichen Implementierung anzuwenden.

\lstset{caption={Aufruf einer Routine vor der Implementierung.}}
\lstset{label=LIS:fwd}
\begin{table}[h!]
\begin{lstlisting}
forward procedure print()

print()

body procedure print()
  put "Print"
end print
\end{lstlisting}
\end{table}

\"Ahnlich C wird in Listing \ref{LIS:fwd} erst der Prototyp der Routine bekanntgegeben und ein \lstinline{forward} vorangestellt. An entsprechender Stelle wird der Implementierung das Schl\"usselwort \lstinline{body} beigef\"ugt um klarzustellen, dass dies die Implementierung einer bereits definierten Routine ist.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Strings}

\texttt{Turing} verf\"ahrt mit Strings auf eine etwas angenehmere Art und Weise als das gro\ss{}e Vorbild Pascal. Prinzipiell muss die L\"ange des Strings bei der Deklaration nicht bekannt sein. Auch ist keine explizite Speicherallozierung notwendig. Um einen String zu kreieren gen\"ugt also:

\lstset{caption={Deklaration eines Strings.}}
\lstset{label=LIS:str:decl}
\begin{table}[h!]
\begin{lstlisting}
var message : string
\end{lstlisting}
\end{table}

Wichtig bei der Verwendung von Strings ist es zu beachten, dass sie eine maximale L\"ange von nur 255 Zeichen annehmen k\"onnen. Kommt es dennoch zu einer Konkatenation von mehr als 255 Zeichen, reagiert \texttt{Turing} mit einem Laufzeitfehler.

Besonders angenehm gestalten sich die wichtigsten Operationen auf Strings. Zur Konkatenation zweier Strings gen\"ugt der $+$-Operator:

\lstset{caption={Stringkonkatenation.}}
\lstset{label=LIS:str:conc}
\begin{table}[h!]
\begin{lstlisting}
message := "This is a " + "split" + " message."
\end{lstlisting}
\end{table}

\texttt{Turing} bietet auch einfache M\"oglichkeiten Substrings zu extrahieren. 

\lstset{caption={Zugriff auf Teile eines Strings.}}
\lstset{label=LIS:str:sub}
\begin{table}[h!]
\begin{lstlisting}
put message(1 .. 4)
put message(*-7 .. *)
\end{lstlisting}
\end{table}

Die erste Anweisung gibt ``This'' aus. Zu beachten ist dabei, dass Strings beginnend bei 1 indiziert werden. \\
Das Symbol * verweist auf den Index des letzten Zeichens. In der zweiten Anweisung werden die letzten sieben Zeichen des \texttt{message} Strings also ``message.'' ausgegeben. \\

Daneben gibt es noch zahlreiche vordefinierte Funktionen, wie 

\begin{itemize}
   \item \lstinline{length(string) : int} gibt die L\"ange des Strings zur\"uck.
   \item \lstinline{index(string, string) : int} findet die erste Position eines Substrings in einem String.
   \item \lstinline{strok(string) : boolean} ist wahr, wenn der String fehlerlos in eine Nummer konvertiert werden kann.
   \item \lstinline{intstr(string) : int} konvertiert einen String in einen Integer.
\end{itemize}

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Types und Records}

Typdefinitionen erlauben es, benutzerdefinierte Datentypen zu kreieren. 

\lstset{caption={Benutzerdefinierte Typen.}}
\lstset{label=LIS:type}
\begin{table}[!h]
\begin{lstlisting}
type nameType : string(30)
type range    : 0 .. 150
\end{lstlisting}
\end{table}

Hier wird ein Stringtyp mit einer fixen L\"ange von 30 Zeichen und ein numerischer Typ, der Werte auf einen Teilbereich einschr\"ankt, definiert. \\
Die Datentypen k\"onnen dabei auch komplexere Strukturen annehmen, indem Records verwendet werden. Listing \ref{LIS:type:record} zeigt ein Beispiel.

\lstset{caption={Strukturierung mit Records.}}
\lstset{label=LIS:type:record}
\begin{table}[h!]
\begin{lstlisting}
type entry : record
  name : nameType
  age  : int
end record
\end{lstlisting}
\end{table}

Die Deklaration von Variablen benutzerdefinierten Typs geschieht wie gewohnt. Auf Elemente eines Records wird mit dem Punkt-Operator zugegriffen. 

\lstset{caption={Verwendung von Records.}}
\lstset{label=LIS:type:record:usage}
\begin{table}[h!]
\begin{lstlisting}
var me : entry
me.name := "Mathias Hoertnagl"
me.age  := 26
put "Name: ", me.name
\end{lstlisting}
\end{table}

\newpage

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Arrays}

Die Definition von Array geschieht in \texttt{Turing} wie in folgendem Beispiel.

\lstset{caption={Definition eines Arrays.}}
\lstset{label=LIS:arr:def}
\begin{table}[h!]
\begin{lstlisting}
var marks : array 1 .. 100 of int
\end{lstlisting}
\end{table}

Dies erzeugt ein Array der Gr\"o\ss{}e 100 vom Datentyp \lstinline{int}. Erlaubt sind ebenfalls Variablen als Bereichsgrenzen. Die Zellen des Array sind nach der Deklaration nicht initialisiert. Dies muss gesondert f\"ur jedes Element des Arrays erfolgen. 

\lstset{caption={Zugriff auf Elemente eines Arrays.}}
\lstset{label=LIS:arr:usage}
\begin{table}[h!]
\begin{lstlisting}
marks(1) := 1
put marks(1)
\end{lstlisting}
\end{table}

%\subsubsection{Dynamische Arrays}

In \texttt{Turing} ist es erlaubt, Arrays nach Deklaration verlustfrei in ihrer Ausdehnung zu vergr\"o\ss{}ern. Wird das Array verk\"urzt, so gehen die Inhalte der betroffenen Elemente verloren. 

\lstset{caption={Definition eines dynamischen Arrays.}}
\lstset{label=LIS:arr:dyn}
\begin{table}[h!]
\begin{lstlisting}
var marks : flexible array 1 .. 100 of int
\end{lstlisting}
\end{table}

Mit dem Schl\"usselwort \lstinline{flexible} wird dem Compiler mitgeteilt, dass das Array w\"ahrend der Laufzeit seine Gr\"o\ss{}e \"andern kann.

\lstset{caption={Vergr\"o\ss{}erung eines dynamischen Arrays.}}
\lstset{label=LIS:arr:dyn:rez}
\begin{table}[h!]
\begin{lstlisting}
new marks, 200
\end{lstlisting}
\end{table}

In Listing \ref{LIS:arr:dyn:rez} wird das vorher auf 100 Elemente limitierte Array auf 200 erweitert. Bereits vorher gespeicherte Elemente bleiben erhalten. Diese flexible Behandlung von Arrays ist allerdings auf die erste Dimension beschr\"ankt.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Module}

Zur Organisation gro\ss{}er Projekte bietet \texttt{Turing} die M\"oglichkeit der Strukturierung und Kapselung von logischen Komponenten mittels Modulen an. \\
Listing \ref{LIS:stack:module} zeigt eine Implementierung eines Stacks f\"ur Strings. Die Moduldefinition verbirgt dabei alle Variablen, Prozeduren und Funktionen, die nicht explizit in \lstinline{export} aufgez\"ahlt werden.

\newpage

\lstset{caption={Organisation einer Stackimplementierung mittels Modulen \cite{www:doc}.}}
\lstset{label=LIS:stack:module}
\begin{table}[h!]
\begin{lstlisting}
module stack
  export push, pop, var top

  var top : int := 0
  var contents : array 1 .. 100 of string

  procedure push(s : string)
    top := top + 1
    contents(top) := s
  end push

  procedure pop(var s : string)
    s := contents(top)
    top := top - 1
  end pop
end stack
\end{lstlisting}
\end{table}

Sollen Variablen global sichtbar sein, so werden diesen, wie am Beispiel von \texttt{top} ersichtlich, ein \lstinline{var} in der Exportaufstellung vorangestellt. \\
Verwendet werden kann das Stack-Modul wie folgt:
\lstset{caption={Exemplarische Verwendung des Stack-Moduls.}}
\lstset{label=LIS:stack:module:use}
\begin{table}[h!]
\begin{lstlisting}
stack.push("Satan")
put stack.top
var name : string
stack.pop(name)
put stack.top
\end{lstlisting}
\end{table}

Besonders wichtig ist hier der Unterschied zu Objekten, da Module nicht instanziiert werden und demzufolge in diesem Beispiel immer nur ein Stack existiert auf dem operiert wird.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Sound, Grafiken und GUIs}

Eine Bibliothek bietet Unterst\"utzung bei der Entwicklung von grafischen Benutzeroberfl\"achen als auch beim Zeichnen von Grafiken und Sprites. Zus\"atzlich steht noch eine rudiment\"are Bibliothek zur Wiedergabe einfacher Tonsequenzen bereit. \\
Andere vordefinierte Bibliotheken, die etwa grundlegende Datenstrukturen implementieren, fehlen in \texttt{Turing} g\"anzlich. \\

Dies schlie\ss{}t die Diskussion der grundlegenden Sprachkonzepte von Turing. Im n\"achsten Kapitel werden die systemnahen Erweiterungen von Turing Plus n\"aher er\"ortert.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\section{Systemprogrammierung}
\label{chap:system}

Mit Turing Plus erfuhr die Programmiersprache eine Erweiterung hin zur systemnahen Sprache. Hinzu kamen unter anderem vorzeichenlose Datentypen, unsichere Typkonvertierungen, Pointer, Pointerarithmetik. Zus\"atzlich konnten nun auch Prozesse erzeugt und synchronisiert werden \cite{Holt:88}.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Zeiger}

Die wichtigste Neuerung stellt dabei die Unterst\"utzung von Zeigern dar. Der Beispielcode aus Listing \ref{LIS:ptr} deklariert dabei einen Zeiger auf eine nat\"urliche Zahl auf zwei Arten.

\lstset{caption={Definition eines Zeigers.}}
\lstset{label=LIS:ptr}
\begin{table}[h!]
\begin{lstlisting}
var pNat  : pointer of nat
var pNat2 : ^nat
\end{lstlisting}
\end{table}

Die zweite Deklaration ist lediglich eine Kurzform der ersten. Zeiger spielen insbesondere in der objekt-orientierten Programmierung eine Rolle, da alle Objektvariablen Zeiger auf die sie instanziierende Klasse sind. Ein Beispiel f\"ur eine solche Instanziierung enth\"alt Kapitel \ref{LBL:object-creation}. \\
Mit der Einf\"uhrung von Zeigern wurden auch explizite Konvertierungen von primitiven Datentypen notwendig, um die sonst strikte Typisierung von \texttt{Turing} zu lockern, ohne sie g\"anzlich aufgeben zu m\"ussen.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Prozesse}

Die Erzeugung eines Prozesses erfolgt in zwei Schritten. In Listing \ref{LIS:process} wird erst in einem \lstinline{process}-Block die Funktionalit\"at eines Prozesses implementiert und anschlie\ss{}end mit \lstinline{fork} ein neue Prozess erzeugt.

\lstset{caption={Ein einfacher Prozess \cite{www:doc}.}}
\lstset{label=LIS:process}
\begin{table}[h!]
\begin{lstlisting}
process speak(word: string)
  loop
    put word
  end loop
end speak

fork speak("Hi") % Start saying: Hi Hi Hi . . .
fork speak("Ho") % Start saying: Ho Ho Ho . . .
\end{lstlisting}
\end{table}

Zur Synchronisation von Prozessen, stellt \texttt{Turing} dem Entwickler ausschlie\ss{}lich Monitore zur Verf\"ugung \cite{Perelgut:88}. \\

Nach dieser kurzen Einf\"uhrung in die wichtigsten systemnahen Elemente von \texttt{Turing}, soll das n\"achste Kapitel einen \"Uberblick \"uber die objekt-orientierte Programmierung geben. 

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\section{Objekt-orientierte Programmierung}
\label{chap:oop}

In diesem Kapitel wird die Umsetzung des objekt-orientierten Paradigmas in \texttt{Turing} diskutiert. Die Vererbung ist auf eine Superklasse beschr\"ankt. Methoden werden nur anhand ihres Namens, nicht aber anhand der Parametertypen unterschieden. \texttt{Turing} besitzt wie C++ keinen Garbage-Collector. 

\subsection{Klassendefinitionen}

In Listing \ref{LIS:stack class} entsprechend \cite{www:doc} soll exemplarisch ein Stack als Klasse implementiert werden. Die Definition  \"ahnelt jener von Modulen. \"uber das Schl\"usselwort \lstinline{export} werden die \"offentlich zug\"anglichen Methoden und Funktionen angegeben.

\lstset{caption={Stack als Klasse.}}
\lstset{label=LIS:stack class}
\begin{table}[h!]
\begin{lstlisting}
class Stack
  export push, pop
  
  var top : int := 0
  var contents : array 1 .. 100 of string

  proc push(s : string)
    top := top + 1
    contents(top) := s
  end push

  proc pop(var s : string)
    s := contents(top)
    top := top - 1
  end pop
end Stack
\end{lstlisting}
\end{table}

\texttt{Turing}-Klassen ben\"otigen keinen Konstruktor, wie er etwa in C++ oder Java \"ublich ist.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Objekterzeugung}
\label{LBL:object-creation}

Erzeugen neuer Instanzen von Klassen geschieht in zwei Schritten. Wie in Listing \ref{LIS:stack instance} abgebildet wird zuerst eine Variable als Zeiger auf die Klasse \texttt{Stack} erzeugt. Anschlie\ss{}end wird diese Klasse neu instanziiert. Das Schl\"usselwort \lstinline{new} verlangt dabei die Variable, die auf das neu instanziierte Objekt verweist.

\lstset{caption={Eine Instanz der Klasse Stack.}}
\lstset{label=LIS:stack instance}
\begin{table}[h!]
\begin{lstlisting}
var stack : ^Stack
new stack
\end{lstlisting}
\end{table}

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Zugriff auf Elemente eines Objekts}

Auf mit \lstinline{export} gelistete Methoden, Funktionen und Variablen kann mit dem \texttt{->}-Operator zugegriffen werden. Dieser besitzt die selbe Semantik wie in C++. Erst wird der Zeiger dereferenziert und anschlie\ss{}end die Methode oder Funktion aufgerufen. 

\lstset{caption={Aufruf einer Methode mit \texttt{->}.}}
\lstset{label=LIS:stack call}
\begin{table}[h!]
\begin{lstlisting}
stack->push("Satan")
\end{lstlisting}
\end{table}

Alternativ kann der Zeiger explizit dereferenziert werden, indem der umklammerten Variable die Klasse vorangestellt wird, als die sie interpretiert werden soll. Anschlie\ss{}end kann mit dem Punkt-Operator die gew\"unschte Methode aufgerufen werden. 

\lstset{caption={Aufruf einer Methode mit dem Punkt-Operator.}}
\lstset{label=LIS:stack call2}
\begin{table}[h!]
\begin{lstlisting}
Stack(stack).push("Satan") 
\end{lstlisting}
\end{table}

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Vererbung}

\texttt{Turing} unterscheidet nicht zwischen Klassen, abstrakten Klassen oder Interfaces wie wir es von Java gewohnt sind. Sollen bestimmte Methoden einer Klasse erst von einer Subklasse implementiert werden, so m\"ussen diese mit \lstinline{deferred} markiert werden. 

\lstset{caption={Stack als Klasse.}}
\lstset{label=LIS:stack class}
\begin{table}[h!]
\begin{lstlisting}
class Stack
  export push, pop
  
  deferred proc push(s : string)
  deferred proc pop(s : string)
end Stack
\end{lstlisting}
\end{table}

Vererbung in \texttt{Turing} bietet nur die M\"oglichkeit von einer Klasse zu erben. Da Interfaces auch nur Klassen sind, kann de facto nur von einer einzigen Klasse geerbt werden. In Listing \ref{LIS:stack:real} erbt die Klasse \lstinline{RealStack} von \lstinline{Stack}. Die Superklasse wird mit dem Schl\"usselwort \lstinline{inherit} angegeben.

\lstset{caption={\lstinline{RealStack} erbt von \lstinline{Stack}.}}
\lstset{label=LIS:stack:real}
\begin{table}[h!]
\begin{lstlisting}
class RealStack
  inherit Stack
  ... 
  body proc push(s : string) 
    ...
  end push
  
  body proc pop(s : string)
    ...
  end pop
end RealStack
\end{lstlisting}
\end{table}
%%% !!!
Jede bereits in der Superklasse exportierte Methode, die erstmalig oder erneut implementiert werden soll, muss mit \lstinline{body} versehen werden. 

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Die Wurzelklasse anyclass}

An der Wurzel der Vererbungshierarchie in \texttt{Turing} steht nicht \texttt{Object} mit einigen wenigen n\"utzlichen Methoden wie in Java, sondern das methodenlose \lstinline{anyclass}. Wie der Name schon verr\"at, k\"onnen Variablen dieses Typs, Objekte jeder Klasse in \texttt{Turing} halten.

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsubsection{Klassenidentifikation zur Laufzeit}

Um die Klasse eines Objekts zur Laufzeit erhalten zu k\"onnen, stellt \texttt{Turing} die Funktion \lstinline{objectclass(^anyclass)} zur Verf\"ugung:

\lstset{caption={Klassenidentifikation zur Laufzeit.}}
\lstset{label=LIS:stack:objectclass}
\begin{table}[h!]
\begin{lstlisting}
var c : ^anyclass
if objectclass(c) = ClassA then
  ...
elsif objectclass(c) >= ClassB then
  ...
end if 
\end{lstlisting}
\end{table}

Es k\"onnen die \"ublichen Vergleichsoperatoren verwendet werden. Insbesondere kann mit ermittelt werden, ob das Objekt \lstinline{c} eine Instanz der Klasse \lstinline{ClassB} oder einer Subklasse von \lstinline{ClassB} ist.

%\lstset{caption={.}}
%\lstset{label=LIS:stack:objectclass:2}
\begin{table}[h!]
\begin{lstlisting}
objectclass(c) >= ClassB
\end{lstlisting}
\end{table}

\newpage

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\subsection{Objektzerst\"orung}
\label{object }
Erzeugte Objekte m\"ussen vom Programmierer manuell wieder entfernt werden. 

\lstset{caption={Zerst\"oren eines Objektes.}}
\lstset{label=LIS:stack:free}
\begin{table}[h!]
\begin{lstlisting}
var stack : ^Stack
free stack
\end{lstlisting}
\end{table}

% +----------------------------------------------------------------------------+
% | 
% +----------------------------------------------------------------------------+
\section{Zusammenfassung und Ausblick}

Mitte der 1980er Jahre konnte \texttt{Turing} noch mit einigen interessanten Aspekten punkten und in einigen Bereichen den gro\ss{}en Konkurrenten Pascal \"ubertrumpfen. Die Erweiterungen brachten keine nennenswerte Vergr\"o\ss{}erung des Wirkungsbereichs der Sprache und besonders die Umsetzung des objekt-orientierten Paradigmas ist empfindlich unvollst\"andig. \\
Die von \texttt{Turing} bereitgestellten Bibliotheken decken nur enge Teilbereiche, wie etwa die GUI-Programmierung ab, mehrheitlich fehlen aber Implementierungen von wichtigen Datenstrukturen wie HashTables oder Listen. Strukturen, die durchaus von Programmieranf\"angern rudiment\"ar implementiert werden k\"onnen, die der professionelle Entwickler aber nicht missen m\"ochte. \\

Dennoch wird die Sprache an vielen Highschools Ontario's noch heute in Einf\"uhrungskursen zur Programmierung genutzt. 
%Ein Umstand der sich mit der eingestellten Weiterentwicklung und Unterst\"utzung durch Holtsoft bald \"andern k\"onnte.